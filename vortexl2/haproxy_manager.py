import subprocess
import logging
from pathlib import Path
from typing import List, Tuple, Dict, Optional

# Setup logging
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

from vortexl2.config import ConfigManager

# HAProxy configuration paths
HAPROXY_CONFIG_DIR = Path("/etc/haproxy")
HAPROXY_CONFIG_FILE = HAPROXY_CONFIG_DIR / "haproxy.cfg"
HAPROXY_BACKUP_FILE = HAPROXY_CONFIG_DIR / "haproxy.cfg.bak"


class HAProxyManager:
    """Manages HAProxy for port forwarding."""
    
    def __init__(self, config=None):
        self.config = config
        self.haproxy_config_path = HAPROXY_CONFIG_FILE
        self.running = False
    
    def _generate_haproxy_config(self) -> str:
        """Generate HAProxy configuration matching test.sh style."""
        config = """# HAProxy configuration generated by VortexL2
global
    log /dev/log    local0
    log /dev/log    local1 notice
    chroot /var/lib/haproxy
    stats socket /run/haproxy/admin.sock mode 660 level admin
    stats timeout 30s
    user haproxy
    group haproxy
    daemon

defaults
    log     global
    mode    tcp
    option  tcplog
    option  dontlognull
    timeout connect 5000ms
    timeout client  50000ms
    timeout server  50000ms

"""
        
        # Get all configured tunnels
        config_manager = ConfigManager()
        tunnels = config_manager.get_all_tunnels()
        
        if not tunnels:
            return config  # Return just global/defaults if no tunnels
        
        # For each tunnel and port create frontend+backend (simple style like test.sh)
        for tunnel in tunnels:
            remote_ip = getattr(tunnel, 'remote_forward_ip', None)
            tunnel_name = tunnel.name
            if not remote_ip:
                logger.debug(f"Skipping tunnel {tunnel_name}: no remote_forward_ip")
                continue
            if not getattr(tunnel, 'forwarded_ports', None):
                logger.debug(f"Skipping tunnel {tunnel_name}: no forwarded_ports")
                continue

            for port in tunnel.forwarded_ports:
                # Simple naming like test.sh
                config += f"""frontend frontend_{port}
    bind *:{port}
    default_backend backend_{port}

backend backend_{port}
    server server_{port} {remote_ip}:{port}

"""
        return config
    
    def _write_config_file(self, config_content: str) -> bool:
        """Write HAProxy configuration to file."""
        try:
            HAPROXY_CONFIG_DIR.mkdir(parents=True, exist_ok=True)
            
            # Backup existing config if it exists and no backup yet
            if HAPROXY_CONFIG_FILE.exists() and not HAPROXY_BACKUP_FILE.exists():
                import shutil
                shutil.copy2(HAPROXY_CONFIG_FILE, HAPROXY_BACKUP_FILE)
                logger.info(f"Backed up original HAProxy config to {HAPROXY_BACKUP_FILE}")
            
            # Write config directly
            with open(HAPROXY_CONFIG_FILE, 'w') as f:
                f.write(config_content)
            
            logger.info(f"Generated HAProxy config: {HAPROXY_CONFIG_FILE}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to write HAProxy config: {e}")
            return False
    
    def _reload_haproxy(self) -> bool:
        """Reload HAProxy configuration gracefully."""
        try:
            # Try systemctl restart (more reliable than reload)
            result = subprocess.run(
                ["systemctl", "restart", "haproxy"],
                capture_output=True,
                timeout=15
            )
            
            if result.returncode == 0:
                logger.info("HAProxy reloaded successfully")
                return True
            
            logger.error(f"HAProxy restart failed: {result.stderr.decode()}")
            return False
            
        except subprocess.TimeoutExpired:
            logger.error("HAProxy reload timeout")
            return False
        except Exception as e:
            logger.error(f"Failed to reload HAProxy: {e}")
            return False
    
    def create_forward(self, port: int) -> Tuple[bool, str]:
        """Add a port forward."""
        if not self.config:
            return False, "No tunnel configuration provided"
            
        if port in self.config.forwarded_ports:
            return False, f"Port {port} already in forwarded list"
        
        # Check if port is already in use
        if self._is_port_listening(port):
            process_info = self._get_port_process(port)
            if process_info:
                return False, f"Port {port} is already in use by: {process_info}"
            else:
                return False, f"Port {port} is already in use by another process"
        
        # Add to config
        self.config.add_port(port)
        
        # Generate the new configuration for all tunnels
        config = self._generate_haproxy_config()
        
        # Write the new configuration to the file
        if not self._write_config_file(config):
            return False, "Failed to write HAProxy configuration"
        
        # Reload HAProxy to apply the new configuration
        if not self._reload_haproxy():
            return False, "Failed to reload HAProxy"
        
        return True, f"Port forward for port {port} created successfully."
    
    def remove_forward(self, port: int) -> Tuple[bool, str]:
        """Remove a single port forward by updating HAProxy configuration."""
        if not self.config:
            return False, "No tunnel configuration provided"
            
        if port not in self.config.forwarded_ports:
            return False, f"Port {port} is not in forwarded list"
        
        # Remove from config
        self.config.remove_port(port)
        
        # Generate updated configuration 
        current_config = self._generate_haproxy_config()
        
        # Write updated configuration
        if not self._write_config_file(current_config):
            return False, "Failed to update HAProxy configuration"
        
        # Reload HAProxy to apply changes
        if not self._reload_haproxy():
            return False, "Failed to reload HAProxy"
        
        return True, f"Port forward for {port} removed"

    def validate_and_reload(self) -> Tuple[bool, str]:
        """Validate generated HAProxy config and reload HAProxy gracefully."""
        try:
            config = self._generate_haproxy_config()
            if not config:
                return False, "No HAProxy configuration generated (no tunnels or missing data)"

            # Write config
            if not self._write_config_file(config):
                return False, "HAProxy configuration write failed"

            # Reload HAProxy
            if not self._reload_haproxy():
                return False, "HAProxy reload failed"

            return True, "HAProxy configuration validated and reloaded successfully"
        except Exception as e:
            return False, f"Error during validate_and_reload: {e}"
    
    def add_multiple_forwards(self, ports_str: str) -> Tuple[bool, str]:
        """Add multiple port forwards from comma-separated string or range."""
        results = []
        ports = []
        
        # Parse ports (supports: 443, 8443 or 443-450 range)
        try:
            for part in ports_str.split(','):
                part = part.strip()
                if '-' in part:
                    start, end = map(int, part.split('-'))
                    ports.extend(range(start, end + 1))
                else:
                    ports.append(int(part))
        except ValueError:
            return False, "Invalid port format"
        
        active_ports = []
        inactive_ports = []
        
        for port in ports:
            success, msg = self.create_forward(port)
            
            if success:
                active_ports.append(port)
                results.append(f"✓ Port {port}: ACTIVE")
            else:
                inactive_ports.append(port)
                results.append(f"✗ Port {port}: {msg}")
        
        # Summary at the end
        if active_ports and inactive_ports:
            summary = f"\nSummary: {len(active_ports)} activated, {len(inactive_ports)} failed"
            results.append(summary)
        elif active_ports:
            results.append(f"\nAll {len(active_ports)} port(s) activated successfully")
        elif inactive_ports:
            results.append(f"\nAll {len(inactive_ports)} port(s) failed")
        
        return True, "\n".join(results)
    
    def remove_multiple_forwards(self, ports_str: str) -> Tuple[bool, str]:
        """Remove multiple port forwards from comma-separated string or range."""
        results = []
        ports = []
        
        # Parse ports (supports: 443, 8443 or 443-450 range)
        try:
            for part in ports_str.split(','):
                part = part.strip()
                if '-' in part:
                    start, end = map(int, part.split('-'))
                    ports.extend(range(start, end + 1))
                else:
                    ports.append(int(part))
        except ValueError:
            return False, "Invalid port format"
        
        for port in ports:
            success, msg = self.remove_forward(port)
            results.append(f"Port {port}: {msg}")
        
        return True, "\n".join(results)
    
    def list_forwards(self) -> List[Dict]:
        """List all configured port forwards from all tunnels."""
        forwards = []
        
        # Get all tunnels to show all forwards
        cm = ConfigManager()
        tunnels = cm.get_all_tunnels()
        
        for tunnel in tunnels:
            remote_ip = getattr(tunnel, 'remote_forward_ip', None)
            if not remote_ip:
                continue
                
            for port in tunnel.forwarded_ports:
                forwards.append({
                    "port": port,
                    "tunnel": tunnel.name,
                    "remote": f"{remote_ip}:{port}",
                    "active": self._is_port_listening(port),
                    "active_sessions": 0,
                    "stats": {}
                })
        
        return forwards
    
    def _is_port_listening(self, port: int) -> bool:
        """Check if a port is listening."""
        try:
            # Check using ss
            result = subprocess.run(
                f"ss -tlnp 2>/dev/null | grep -E ':{port}\\b'",
                shell=True,
                capture_output=True,
                timeout=5
            )
            if result.returncode == 0:
                return True
            
            # Fallback: check with netstat
            result = subprocess.run(
                f"netstat -tlnp 2>/dev/null | grep -E ':{port}\\b'",
                shell=True,
                capture_output=True,
                timeout=5
            )
            return result.returncode == 0
        except Exception:
            return False
    
    def _get_port_process(self, port: int) -> Optional[str]:
        """Get the process using a specific port."""
        try:
            # Try lsof
            result = subprocess.run(
                f"lsof -i :{port} -t 2>/dev/null | head -1",
                shell=True,
                capture_output=True,
                timeout=5,
                text=True
            )
            if result.returncode == 0 and result.stdout.strip():
                pid = result.stdout.strip()
                # Get process name from pid
                ps_result = subprocess.run(
                    f"ps -p {pid} -o comm=",
                    shell=True,
                    capture_output=True,
                    timeout=5,
                    text=True
                )
                if ps_result.returncode == 0 and ps_result.stdout.strip():
                    process_name = ps_result.stdout.strip()
                    return f"{process_name} (PID: {pid})"
                return f"PID: {pid}"
            
            return None
        except Exception:
            return None
    
    async def start_all_forwards(self) -> Tuple[bool, str]:
        """Start all configured port forwards from all tunnels."""
        # Get all tunnels from disk
        cm = ConfigManager()
        tunnels = cm.get_all_tunnels()
        
        # Check if any tunnels have forwarded ports
        has_forwards = any(t.forwarded_ports for t in tunnels)
        if not has_forwards:
            return True, "No port forwards configured"
        
        # Generate and write configuration
        config = self._generate_haproxy_config()
        if not self._write_config_file(config):
            return False, "Failed to write HAProxy configuration"
        
        # Start/restart HAProxy
        try:
            result = subprocess.run(
                ["systemctl", "restart", "haproxy"],
                capture_output=True,
                timeout=15,
                text=True
            )
            
            if result.returncode != 0:
                stderr_msg = result.stderr.strip() if result.stderr else "Unknown error"
                return False, f"Failed to start HAProxy: {stderr_msg}"
            
            self.running = True
            
            # Collect all forwarded ports
            all_ports = set()
            for tunnel in tunnels:
                all_ports.update(tunnel.forwarded_ports)
            ports_str = ", ".join(sorted(str(p) for p in all_ports))
            msg = f"HAProxy started with ports: {ports_str}" if ports_str else "HAProxy started"
            logger.info(msg)
            return True, msg
            
        except subprocess.TimeoutExpired:
            return False, "Timeout starting HAProxy"
        except Exception as e:
            logger.error(f"Exception in start_all_forwards: {e}")
            return False, f"Error starting HAProxy: {e}"
    
    async def stop_all_forwards(self) -> Tuple[bool, str]:
        """Stop all configured port forwards."""
        try:
            result = subprocess.run(
                ["systemctl", "stop", "haproxy"],
                capture_output=True,
                timeout=10
            )
            
            self.running = False
            return True, "HAProxy stopped"
            
        except Exception as e:
            return False, f"Error stopping HAProxy: {e}"
    
    async def restart_all_forwards(self) -> Tuple[bool, str]:
        """Restart all configured port forwards."""
        await self.stop_all_forwards()
        import asyncio
        await asyncio.sleep(1)
        return await self.start_all_forwards()


# Backward compatibility alias
ForwardManager = HAProxyManager
